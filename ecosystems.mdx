<pre>
═════════════════════
MARKET DATA ECOSYSTEM, Full list of assets with stats in markets.tsx, Asset selector and Header in Futures / Spot
═════════════════════

FILES:
<a href="server/src/ws/streams/spotStats.ts">spotStats.ts</a>, 
<a href="server/src/ws/streams/futuresStats.ts">futuresStats.ts</a>, 
<a href="server/src/ws/streams/markets.ts">markets.ts</a>, 

<a href="web/src/contexts/MarketContext.tsx">MarketContext.tsx</a>, 
<a href="web/src/routes/Markets.tsx">Markets.tsx</a>

<a href="web/src/components/BigPrice.tsx">BigPrice.tsx</a>
<a href="web/src/components/PriceChart.tsx">PriceChart.tsx</a>

<a href="web/src/routes/Spot.tsx">Spot.tsx</a>, <a href="web/src/routes/Futures.tsx">Futures.tsx</a>

COMPLETE DATA FLOW:
   spotStats.ts, futuresStats.ts (5 seconds)
   spotTicks.ts, futuresTicks.ts (1 second)
    │
    ├─→ BACKEND (Internal)
    │      └─→ priceService.updatePrice() Used by FuturesEngine/SpotEngine
    │
    └─→ FRONTEND (WebSocket Fan-Out)
           ↓
        Read Subscriber Map (Contains both "sub_all" and "sub" clients)
           ↓
        Iterate & Send to all subscribers
        <a href="server/src/ws/streams/spotStats.ts#L54">spotStats.ts:54</a> | <a href="server/src/ws/streams/futuresStats.ts#L59">futuresStats.ts:59</a>
           │
           ├─→ MarketContext (Receives Bulk List)
           │      └─→ UI Updates: Markets.tsx (Market List) <a href="web/src/routes/Markets.tsx#L13">Markets.tsx:13</a>
           │
           ├─→ Headers in Spot/Futures (Receives Single Symbol)
           │      └─→ setStats() (Local State)
           │             ↓
           │          UI Updates:
           │          ├─→ Spot.tsx Header <a href="web/src/routes/Spot.tsx#L74">Spot.tsx:74</a>
           │          └─→ Futures.tsx Header <a href="web/src/routes/Futures.tsx#L82">Futures.tsx:82</a>
           │
           └─→ PriceContext (Listens to Ticks)
                  ↓
               usePrice() hook (Shared 'tick' variable) <a href="web/src/contexts/PriceContext.tsx#L151">PriceContext.tsx:151</a>
                  │
                  ├─→ BigPrice.tsx (Uses 'tick') <a href="web/src/components/BigPrice.tsx#L19">BigPrice.tsx:19</a>
                  │
                  └─→ PriceChart.tsx (Chart)
                         │
                         ├─→ History (REST): GET /api/markets/spot/klines <a href="web/src/components/PriceChart.tsx#L143">PriceChart.tsx:143</a>
                         │
                         └─→ Live (WS): usePrice() hook <a href="web/src/components/PriceChart.tsx#L160">PriceChart.tsx:160</a>
</pre>











<pre>
═════════════════════════════
FUTURES ECOSYSTEM
═════════════════════════════

<b>FILES:</b> 
<a href="web/src/routes/Futures.tsx">Futures.tsx</a>
<a href="server/src/routes/futures.ts">futures.ts</a>
<a href="server/src/utils/futuresEngine.ts">futuresEngine.ts</a>
<a href="server/src/utils/priceService.ts">priceService.ts</a>

<a href="server/src/utils/emitters.ts">emitters.ts</a>
<a href="web/src/contexts/AccountContext.tsx">AccountContext.tsx</a>
<a href="web/src/contexts/AuthContext.tsx">AuthContext.tsx</a>
<a href="server/src/middleware/auth.ts">middleware/auth.ts</a>


<b>OPERATION 1: Open Position</b>
User clicks "Buy/Long" button (Visible only if isAuthed)
<a href="web/src/Futures.tsx#L576">Futures.tsx:576</a>
    ↓
placeOrder('long') function, if (!isAuthed) return
<a href="web/src/Futures.tsx#L127">Futures.tsx:127</a>
    ↓
fetch() → POST /api/futures/orders (Header: Authorization: Bearer ...)
<a href="server/src/futures.ts#L16">futures.ts:16</a>
    ↓
Middleware requireAuth() verifies token & attaches user
<a href="server/src/middleware/auth.ts#L16">middleware/auth.ts:16</a>
    ↓
futures.ts handler writes to DB
    ├─→ FuturesAccount.updateOne()
    ├─→ then FuturesOrder.create()
    └─→ then FuturesPosition.updateOne()
    ↓
then, futures.ts handler calls sync functions <a href="server/src/futures.ts#L94">futures.ts:94-96</a>:
    ├─→ syncFuturesBalances(userId)
    ├─→ syncFuturesPosition(userId, symbol)
    └─→ syncOrder(userId, orderData)
            ↓
        emitAccountEvent() (Backend Broadcast) <a href="server/src/ws/streams/account.ts#L19">account.ts:19</a>
            ↓
        AccountContext.tsx (Frontend Listener) <a href="web/src/contexts/AccountContext.tsx#L169">AccountContext:169</a>
            ├─→ Updates State: setFuturesAvailable(), setFuturesPositions()
            └─→ UI Re-renders:
                   ├─→ Futures.tsx (Position in table)
                   └─→ PriceChart.tsx (Draws entry line) <a href="web/src/components/PriceChart.tsx#L223">PriceChart:223</a>



<b>OPERATION 2: Close Position</b>
User clicks "Close" button on chart <a href="web/src/components/PriceChart.tsx#L288">PriceChart.tsx:288</a>
    ↓
props.onClosePosition(activePosition) callback
    ↓
setPartialCloseData(activePosition) - Updates State in Futures.tsx <a href="web/src/Futures.tsx#L412">Futures.tsx:412</a>
    ↓
Modal opens → User clicks "Confirm Close"
    ↓
closePosition() function in Futures.tsx <a href="web/src/Futures.tsx#L174">Futures.tsx:174</a>
    ↓
fetch() → POST /api/futures/close-position (with Bearer Token) (Middleware requireAuth() verifies token)
<a href="server/src/futures.ts#L181">futures.ts:181</a>
    ↓
futures.ts handler calls futuresEngine.executePositionClose(posId, exitPrice)
<a href="server/src/futures.ts#L194">futures.ts:194</a>
    ↓
executePositionClose()
<a href="server/src/utils/futuresEngine.ts#L249">futuresEngine.ts:249</a>
    ↓
    mongoose.startSession() - start DB transaction
    ↓
    session.withTransaction(async () => {
        ↓
        FuturesPosition.findById(posId) - read position from DB
        ↓
        Calculate (IN PARALLEL):
            ├─→ diff = side === 'long' ? (exitPrice - entryPrice) : (entryPrice - exitPrice)
            ├─→ realizedPnl = closeQty * diff
            ├─→ marginToRelease = (closeQty / totalQty) * pos.margin
            └─→ refund = Math.max(0, marginToRelease + realizedPnl)
        ↓
        FuturesAccount.updateOne() - add refund to available balance <a href="server/src/utils/futuresEngine.ts#L273">L273</a>
        ↓
        FuturesPositionHistory.create() - save history record <a href="server/src/utils/futuresEngine.ts#L279">L279</a>
        ↓
        if (closeQty >= totalQty):
            FuturesPosition.deleteOne() - delete position <a href="server/src/utils/futuresEngine.ts#L286">L286</a>
        else:
            pos.quantity -= closeQty <a href="server/src/utils/futuresEngine.ts#L289">L289</a>
            pos.margin -= marginToRelease
            pos.realizedPnL += realizedPnl
            pos.save() - update position in DB
    })
    ↓
    session.endSession() - commit transaction
    ↓
    syncFuturesBalances(userId) <a href="server/src/utils/futuresEngine.ts#L300">L300</a>
    syncFuturesPosition(userId, symbol) <a href="server/src/utils/futuresEngine.ts#L301">L301</a>
    ↓
    (Same WebSocket flow as Operation 1)
    ↓
    AccountContext.setFuturesPositions() updates
    ↓
    PriceChart re-renders:
        ├─→ if position deleted: removes all price lines from chart
        └─→ if partial close: updates position line with new quantity



<b>OPERATION 3: Set TP / SL</b>
User sets TP/SL in modal
    ↓
POST /api/futures/positions/tpsl
<a href="server/src/futures.ts#L203">futures.ts:203</a>
    ↓
futures.ts handler updates FuturesPosition <a href="server/src/futures.ts#L211">futures.ts:211-214</a>:
    ├─→ tpPrice
    ├─→ slPrice
    ├─→ tpQuantity
    └─→ slQuantity
    ↓
syncFuturesPosition() → emitAccountEvent() → WebSocket → UI updates



<b>OPERATION 4: Cancel Limit Order</b>
User clicks "Cancel" which calls DELETE /api/futures/orders/:id <a href="server/src/futures.ts#L109">futures.ts:109</a>
    ↓
futures.ts handler
    ├─→ Unreserve margin in FuturesAccount
    ├─→ Mark FuturesOrder as cancelled
    │
    └─→ syncFuturesBalances() + syncOrder() → emitAccountEvent() → WebSocket → UI updates

</pre>











<pre>
══════════════════════════
THE ENGINE ROOM
══════════════════════════

<b>FILES:</b> 

<a href="server/src/utils/futuresEngine.ts">futuresEngine.ts</a>
<a href="server/src/utils/priceService.ts">priceService.ts</a>
<a href="server/src/utils/emitters.ts">emitters.ts</a>

<a href="server/src/ws/streams/account.ts">account.ts</a>
<a href="web/src/contexts/AccountContext.tsx">AccountContext.tsx</a>


<b>Explanation:</b> 
Main engine function every 2s and calls all engine functions <a href="server/src/utils/futuresEngine.ts#L26">futuresEngine.ts:26</a>
    │
    ├─→ <b>1. processLimitOrders()</b>: Checks if market price hit a limit order.
    │      └─→ If match: fillOrder() → Update DB → syncOrder(), syncFuturesBalances(), syncFuturesPosition()
    │
    ├─→ <b>2. processTPSL()</b>: Checks if market price hit a TP/SL trigger.
    │      └─→ If match: executePositionClose() → Update DB → syncFuturesBalances(), syncFuturesPosition()
    │
    └─→ <b>3. processLiquidations()</b>: Checks if margin is insufficient.
           └─→ If match: liquidatePosition() → Update DB → syncFuturesBalances(), syncFuturesPosition()
    ↓
(All processes use <b>priceService</b> for the latest market prices)
</pre>











<pre>
══════════════════════════
SPOT ECOSYSTEM
══════════════════════════

<b>FILES:</b>
<a href="web/src/routes/Spot.tsx">Spot.tsx</a>
<a href="server/src/routes/spot.ts">routes/spot.ts</a>
<a href="server/src/utils/spotEngine.ts">spotEngine.ts</a>
<a href="server/src/utils/moneyMovement.ts">moneyMovement.ts</a>
<a href="server/src/utils/priceService.ts">priceService.ts</a>
<a href="server/src/utils/emitters.ts">emitters.ts</a>
<a href="web/src/contexts/AccountContext.tsx">AccountContext.tsx</a>
<a href="server/src/middleware/auth.ts">middleware/auth.ts</a>


<b>OPERATION 1: Place Market Order</b>
User clicks "Buy" or "Sell" button (Visible only if isAuthed)
    ↓
button calls placeOrder('buy')
    ↓
if placeOrder('buy') holds valid token in localStorage runs fetch 
<a href="web/src/routes/Spot.tsx#L19">Spot.tsx:19</a>
    ↓
POST /api/spot/orders (with Bearer Token)
<a href="server/src/routes/spot.ts#L19">routes/spot.ts:19</a>
    ↓
Middleware requireAuth() verifies token
<a href="server/src/middleware/auth.ts#L8">middleware/auth.ts:8</a>
    ↓
Handler writes to DB (SEQUENTIAL):
    ├─→ Get current price from priceService <a href="server/src/utils/priceService.ts#L19">priceService.ts:19</a>
    ├─→ Calculate trade amounts
    └─→ moneyMovement.moveMoney() (Atomic DB Update via $inc) <a href="server/src/utils/moneyMovement.ts#L19">moneyMovement.ts:19</a>
    ↓
Handler calls sync functions (BACKGROUND - Sequential) <a href="server/src/routes/spot.ts#L87">spot.ts:87</a>:
    1. syncStableBalances()
    2. syncSpotPosition()
    3. syncOrder()
    ↓
(Sync block runs in background while server returns HTTP response)



<b>OPERATION 2: Place Limit Order</b>
User clicks "Buy" or "Sell" (limit)
    ↓
POST /api/spot/orders
    ↓
Handler does (SEQUENTIAL):
    1. Reserve balance in SpotPosition
    2. Create SpotOrder with status='pending'
    ↓
Handler calls sync functions (BACKGROUND - Sequential) <a href="server/src/routes/spot.ts#L87">spot.ts:87</a>



<b>OPERATION 3: Cancel Limit Order</b>
User clicks "Cancel"
    ↓
DELETE /api/spot/orders/:id
    ↓
Handler does (SEQUENTIAL):
    1. Unreserve balance in SpotPosition
    2. Mark SpotOrder as cancelled
    ↓
Handler calls sync functions (BACKGROUND - Sequential) <a href="server/src/routes/spot.ts#L87">spot.ts:87</a>


══════════════════════════
BACKGROUND PROCESS (When price changes)
══════════════════════════
spotTicks.ts (every 1s)
<a href="server/src/ws/streams/spotTicks.ts#L20">spotTicks.ts:20</a>
    ↓
Fetch MEXC API
    ↓
Get previous price from priceService cache <a href="server/src/ws/streams/spotTicks.ts#L37">spotTicks.ts:37</a>
    ↓
priceService.updatePrice() <a href="server/src/ws/streams/spotTicks.ts#L43">spotTicks.ts:43</a>
    ↓
If price changed <a href="server/src/ws/streams/spotTicks.ts#L51">spotTicks.ts:51</a>
    ↓
matchSpotLimitOrders(symbol, price) <a href="server/src/ws/streams/spotTicks.ts#L53">spotTicks.ts:53</a>
    ↓
Check pending SpotOrders in DB
    ↓
For each fillable order (SEQUENTIAL):
    1. Unreserve balance
    2. Execute trade (update SpotPosition)
    3. Mark SpotOrder as filled
    4. Emit updates via syncSpotPosition() (BACKGROUND) <a href="server/src/utils/spotEngine.ts#L51">spotEngine.ts:51</a>
</pre>











<pre>
══════════════════════
ORDER BOOK
══════════════════════

<b>FILES:</b>
<a href="server/src/ws/streams/spotDepth.ts">spotDepth.ts</a>, 
<a href="server/src/ws/streams/futuresDepth.ts">futuresDepth.ts</a>, 
<a href="web/src/components/OrderBook.tsx">OrderBook.tsx</a>

<b>COMPLETE FLOW:</b>
COMPONENT MOUNT (OrderBook.tsx):
    ↓
    useEffect() connects to WebSocket:
    ├─→ /ws/spot-depth (if market='spot')
    └─→ /ws/futures-depth (if market='futures')
            ↓
    Sends subscription message:
    { type: 'sub', symbol: 'BTCUSDT', depth: 20 }
            ↓
    BACKEND (spotDepth.ts / futuresDepth.ts):
            ↓
    Receives 'sub' message
            ↓
    Starts Interval (every 1s) for that symbol/depth:
            ↓
    Fetch MEXC API (/api/v3/depth)
            ↓
    Broadcast JSON { bids: [...], asks: [...] } to subscribers
            ↓
    FRONTEND (OrderBook.tsx):
            ↓
    Receives 'depth' message
            ↓
    setBids(), setAsks() → Re-render Order Book UI
</pre>











<pre>
═══════════════
USER PROFILE POLLING ECOSYSTEM (ISOLATED)
═══════════════

<b>FILES:</b>
<a href="server/src/routes/user.ts">routes/user.ts</a>, 
<a href="server/src/utils/portfolio.ts">portfolio.ts</a>, 
<a href="web/src/contexts/AccountContext.tsx">AccountContext.tsx</a>


<b>COMPLETE FLOW:</b>
TRIGGER (any of these):
    ├─→ Page load
    ├─→ Every 10 seconds (polling interval)
    └─→ Window focus event
        ↓
GET /api/user/profile <a href="server/src/routes/user.ts#L16">routes/user.ts:16</a>
        ↓
Handler reads DB (IN PARALLEL) <a href="server/src/routes/user.ts#L22-L26">L22-26</a>:
    ├─→ User.findById()
    ├─→ SpotPosition.find()
    ├─→ FuturesAccount.find()
    └─→ FuturesPosition.find()
        ↓
Calculate totalPortfolioUSD (via portfolio.ts) <a href="server/src/routes/user.ts#L42">L42</a>
        ↓
Return JSON response <a href="server/src/routes/user.ts#L44-L65">L44-65</a>:
    ├─→ user info
    ├─→ spotAvailable (USDT/USDC)
    ├─→ futuresAvailable (USDT/USDC)
    ├─→ positions array
    └─→ futuresPositions array
        ↓
AccountContext receives HTTP response
        ↓
AccountContext.setState() updates state
        ↓
UI re-renders











<pre>
════════════════════════
AUTHENTICATION ECOSYSTEM
════════════════════════

<b>FILES:</b>
<a href="web/src/contexts/AuthContext.tsx">AuthContext.tsx</a>, 
<a href="server/src/routes/auth.ts">routes/auth.ts</a>, 
<a href="server/src/middleware/auth.ts">middleware/auth.ts</a>, 
<a href="server/src/utils/jwt.ts">jwt.ts</a>


<b>OPERATION 1: Login / Register</b>
User submits form
    ↓
AuthContext.login() / register()
    ↓
POST /api/auth/login OR /register <a href="server/src/routes/auth.ts">routes/auth.ts</a>
    ↓
Handler:
    ├─→ Verify credentials / Create User (DB)
    ├─→ Generate Access Token (short-lived)
    ├─→ Generate Refresh Token (long-lived)
    └─→ Set HTTP-Only Cookie (refresh_token)
    ↓
Return JSON { accessToken }
    ↓
AuthContext.persist(accessToken) → Updates State → App becomes "Authed"


<b>OPERATION 2: Silent Refresh (The "Heartbeat")</b>
AuthContext.useEffect (Interval 10m OR Window Focus) <a href="web/src/contexts/AuthContext.tsx#L94">AuthContext.tsx:94</a>
    ↓
refresh() function
    ↓
POST /api/auth/refresh <a href="server/src/routes/auth.ts#L85">routes/auth.ts:85</a>
    ↓
Handler:
    ├─→ Read cookie
    ├─→ Verify Refresh Token (jwt.ts)
    ├─→ Check User DB (version match)
    └─→ Issue NEW Access Token + Rotate Refresh Token
    ↓
AuthContext receives new Access Token
    ↓
verify() → GET /api/user/profile (Ensures token actually works)


<b>OPERATION 3: Protected Route Access</b>
User navigates to /futures
    ↓
Component makes API call (e.g., POST /order)
    ↓
Request Header: Authorization: Bearer &lt;accessToken&gt;
    ↓
Express Middleware (authenticate) <a href="server/src/middleware/auth.ts">middleware/auth.ts</a>
    ↓
Verify Access Token
    ├─→ Valid: req.user set, next() called
    └─→ Invalid: 401 Unauthorized → Frontend triggers refresh or logout


<b>OPERATION 4: Client-Side Protection (No Server Request)</b>
1. Protected Routes <a href="web/src/App.tsx#L52">App.tsx:52</a>
   User tries to access /wallet
       ↓
   &lt;Protected&gt; component checks isAuthed
       ↓
   if (!isAuthed) &lt;Navigate to="/login" /&gt; (Redirects immediately)

2. UI Conditional Rendering <a href="web/src/components/Header.tsx#L94">Header.tsx:94</a>
   Header component checks isAuthed
       ↓
   if (isAuthed) Show "Wallet", "Settings"
   else Show "Login", "Sign up"


<b>OPERATION 5: WebSocket Handshake (Server Request)</b>
AccountContext connects to /ws/account <a href="web/src/contexts/AccountContext.tsx#L151">AccountContext.tsx:151</a>
    ↓
Sends ?token=&lt;accessToken&gt; in URL
    ↓
Server extracts & verifies the token <a href="server/src/ws/streams/account.ts#L114">ws/streams/account.ts:114</a>
    ↓
If valid: Connection upgraded, user added to broadcast list
If invalid: Connection closed immediately
</pre>

